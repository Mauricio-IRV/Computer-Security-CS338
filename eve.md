Name: Mauricio I. Reyes Villanueva
Due: 09/28/2024

### Diffie Hellman
---

- Figure out the shared secret agreed upon by Alice & Bob. This will be an integer.

- Show your work. How did you finder out the shared secret?

- Show precisely where in your process you would have failed if the integers involved were much larger.

---

- In order to determine the shared secret we first need to determine what the random b generated by Bob was. To do this we will need to use the variables we've eves dropped which are $g, p, B$ and $A$. Ideally we would then use the information we know to find $b$ in $B = g^b \mod p$ but that's not possible due to how the mod function works. As such we will instead need to brute force the value of $b$ by finding all values of $b$ that are true for $B = g^p \mod p$ and trying them all until we get the $b$ that is also true for $K = A^b \mod p$ for both Alice & Bob. I did the following with the python script found below:

```
g = 7
p = 97
A = 53
B = 82

# Diffie Hellman
b_potential_keys = []
a_potential_keys = []

# Encryption formula: B = g^b mod p
def get_public_x(g, i, p):
	return g**i % p

for x in range(p):
	if get_public_x(g, x, p) == B:
		# x represents a potential "b" value
		b_potential_keys.append(A**x % p)

	if get_public_x(g, x, p) == A:
		# x represents a potential "a" value
		a_potential_keys.append(B**x % p)
	
# Convert to sets to find the point of intersection
shared_secret = list(set(b_potential_keys) & set(a_potential_keys))

print(shared_secret)

```

- In this script we're finding all public_x's (either Bob or Alice respectively) that are equal to the B or A we've intercepted. Whenever they match we calculate what the key for the the opposing person would be (Alice and Bob respectively). Then we would add them to their respective arrays. After this loops meets completion, we compare the potential keys a & b and find the matching one: which is the shared secret.

- This process would have failed had our prime number been large, and this brute-force approach would be the primary point of failure.

### RSA
---

- Figure out the encrypted message sent from Alice to Bob.

- Show your work. Exactly how did you figure out the message? (You should include an explanation of how the message from Alice to Bob is encoded. That is, how does Alice's intended message (whatever manner of message it may be) correspond to the integers in the plaintext that you end up with after decrypting the encrypted message?)

- Show precisely where in your process you would have failed if the integers involed were much larger.

- Explain, briefly, why the message encoding Alice used would be insecure even if Bob's keys involved larger integers.

---

- Encrypted Message:

  ```
  Dear Bob, check this out. https://www.surveillancewatch.io/ See ya, Alice.
  ```
- In order to figure out the message I first needed to take apart the mathematical formulas that were being performed and "inverse" them (for lack of a better word) with the information we had.

- We knew what e_bob and n_bob were. We also knew that n_bob is derived from p_bob * q_bob. Using the fact that the two are prime numbers we could calculate the prime factorization of n_bob to get $(389, 419)$.

- From here we then used the fact that bob derived d_bob using e which we know is 13, and lambda_n_bob. The problem is that we don't know that lambda_n is, but we can calculate this just like bob did, using lcm(p-1, q-1) which we know is -> lcm(388, 419) = 81092.

- Using this we could then calculate d by using the multiplicative inverse of the original function $e_b * d_b \mod \lambda(n_b) = 1$ to get the private key d.

- This then gives us a decrypted decimal. The problem here is that the decimal is a 16 bit integer, but ascii characters are 8 bits. As such we need to split the dec into 8 bit upper and lower halves. From here we can then convert those halves into 8 bit ascii characters which are then concatonated together, returned, and further concatonated into one large string of the deciphered message.

- Below is my work on how I deciphered the text alongside a step by step breakdown of the code, reiterating what I did and stated above.

```
# (n_bob = p_bob * q_bob) where p & q are two prime numbers
e_bob, n_bob = [13, 162991]

encrypted_msg = [17645, 100861, 96754, 160977, 120780, 90338, 130962, 74096, 128123, 25052, 119569, 39404, 6697, 82550, 126667, 151824, 80067, 75272, 72641, 43884, 5579, 29857, 33449, 46274, 59283, 109287, 22623, 84902, 6161, 109039, 75094, 56614, 13649, 120780, 133707, 66992, 128221]

# Prime factorization of n_bob i.e of 162991
# https://www.calculatorsoup.com/calculators/math/prime-factors.php
p_q_bob_prime_factorization = [389, 419]

# compute n = lcm(p-1, q-1) where lcm(a, b) is the least common multiple of a and b.
# https://www.calculatorsoup.com/calculators/math/lcm.php
lambda_n_bob = 81092

# e_bob formulation: pick 1 < e < lambda_n such that gcd(e, lambda)
# we already know e is 13 though so we can use it to find d

# Find an integer d such that e_bob * d_bob % lambda_n_bob = 1
# Since we have e_bob and lambda_n_bob, but not d_bob, we will need to use 
# modular multiplicative which can be solved with pythons pow method
# https://stackoverflow.com/questions/4798654/modular-multiplicative-inverse-function-in-python
d_bob = pow(e_bob, -1, lambda_n_bob)

print("Private_Key", d_bob)

decrypted_msg = ''

def dec_16bit_to_ascii(dec):
	upper_8_bits = dec & 0xFF
	lower_8_bits = dec >> 8
	
	# Convert to ASCII character
	ascii_upper = chr(upper_8_bits)
	ascii_lower = chr(lower_8_bits)
	
	return ascii_lower + ascii_upper
		

# Needed to separate the two byte numbers used thisi resource
# https://stackoverflow.com/questions/44179072/separate-2-bytes-hexadecimal-in-1-variable-into-2
for cipher in encrypted_msg:
	decrypted_dec = cipher**d_bob % n_bob
	decrypted_msg += dec_16bit_to_ascii(decrypted_dec)

print(decrypted_msg)


# Credits: 

# I received a huge help from Changwoo with figuring out that the cipher was coded in 16bit decimal numbers! I was getting such odd characters when I initially tried to convert to ascii and so it was a large help! I would most likely not have realized this otherwise!

# Additionally, I did not really know the mathematical formula to solve for d until Luke (a friend of mine who is good at math) mentioned to me that I'd need to solve for the modular multiplicative!
```
